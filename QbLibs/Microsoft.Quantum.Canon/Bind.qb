operation Bind1Impl(operations : (Qubit => ())[], target : Qubit) : () {
    Body {
        for (idxOperation in 0..Length(operations) - 1) {
            let op = operations[idxOperation]
            op(target)
        }
    }
}

/// <summary>
///      Given an array of operations acting on a single qubit,
///      produces a new operation that
///      performs each given operation in sequence.
/// </summary>
/// <remark>See Bind1A, Bind1C, and Bind1AC functor variants.</remark>
function Bind1(operations : (Qubit => ())[]) : (Qubit => ()) {
    return Bind1Impl(operations, _)
}

operation Bind1AImpl(operations : (Qubit => () : Adjoint)[], target : Qubit) : () {
    Body {
        Bind1Impl(operations, target)
    }
    Adjoint {
        // TODO: replace with an implementation based on Reversed : 'T[] -> 'T[]
        //       and AdjointAll : ('T => () : Adjointable)[] -> ('T => () : Adjointable).
        for (idxOperation in Length(operations) - 1..0) {
            let op = (Adjoint operations[idxOperation])
            op(target)
        }
    }
}

/// <summary>
///      Given an array of operations acting on a single qubit,
///      produces a new operation that
///      performs each given operation in sequence.
/// </summary>
/// <remark>See Bind1, Bind1C, and Bind1AC functor variants.</remark>
function Bind1A(operations : (Qubit => () : Adjoint)[]) : (Qubit => () : Adjoint) {
    return Bind1AImpl(operations, _)
}

operation Bind1CImpl(operations : (Qubit => () : Controlled)[], target : Qubit) : () {
    Body {
        Bind1Impl(operations, target)
    }

    Controlled (controls) {
        for (idxOperation in 0..Length(operations) - 1) {
            let op = (Controlled operations[idxOperation])
            op(controls, target)
        }
    }
}

/// <summary>
///      Given an array of operations acting on a single qubit,
///      produces a new operation that
///      performs each given operation in sequence.
/// </summary>
/// <remark>See Bind1, Bind1A, and Bind1AC functor variants.</remark>
function Bind1C(operations : (Qubit => () : Controlled)[]) : (Qubit => () : Controlled) {
    return Bind1CImpl(operations, _)
}

operation Bind1ACImpl(operations : (Qubit => () : Adjoint, Controlled)[], target : Qubit) : () {
    Body {
        Bind1Impl(operations, target)
    }

    Adjoint {
        (Adjoint Bind1AImpl)(operations, target)
    }
    Controlled (controls) {
        (Controlled Bind1CImpl)(controls, (operations, target))
    }

    Controlled Adjoint (controls) {
        for (idxOperation in Length(operations) - 1..0) {
            let op = (Controlled Adjoint operations[idxOperation])
            op(controls, target)
        }
    }
}

/// <summary>
///      Given an array of operations acting on a single qubit,
///      produces a new operation that
///      performs each given operation in sequence.
/// </summary>
/// <remark>See Bind1, Bind1A, and Bind1AC functor variants.</remark>
function Bind1AC(operations : (Qubit => () : Adjoint, Controlled)[]) : (Qubit => () : Adjoint, Controlled) {
    return Bind1ACImpl(operations, _)
}

