// Overview of amplitude amplification library
// Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here
// This is called through the operation AmpAmpObliviousByReflectionPhases.
//		This has two registers: "qubitsAncilla" and "qubitsSystem".
//		This accepts two oracles for these reflections of type "OracleReflection" which act only on the "qubitsAncilla" register.
//		This accepts an oracle special to oblivious amplitude amplification of type "OracleOblivious" which acts jointly on both register.
//		The input state to "qubitsAncilla" is assumed to be the unique -1 eigenstate of the first reflection operator.
//
// Reflections about a quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis |0...0>.
//		Our convention for these oracles requires two registers: a single-qubit "qubitFlag" register, and "qubitsState".
//		The oracle of type "OracleState" acts jointly on both registers to create the target state flagged by |1> in the "qubitFlag" register with some real ampitude. 
//		The reflection "OracleReflection" about the this flag state is generated by the operation "ReflectionTargetForOracleState"
//		The reflection "OracleReflection" about the input state to "qubitsAncilla" is generated by the operation "ReflectionFromOracleState"
//		The oracle of type "OracleStateDeterministic" acts on the "qubitState" registers to create the target state exactly with no flag. 
//
// "AmpAmpObliviousByOraclePhases" is a version of oblivious amplitude amplification that accepts oracles "OracleState" and "OracleOblivious" instead of reflections.
//
// Note that amplitude amplification is a special case of oblivious amplitude amplifiction where "OracleOblivious" is the identity operator, and there are no system qubits i.e. "qubitsSystem" is empty.
//		This is called through the operaton "AmpAmByReflectionPhases" and "AmpAmpByOraclePhases".
//
// The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard
//		An example
// The operation AmpAmpObliviousByReflections calls AmpAmpObliviousByReflectionPhases with phases given by AmpAmpPhasesStandard
// 

// TODO: Different parameter choice for fixed-point
// TODO: Unittests for amplitudeamplification routines
// TODO: Amplitude estimation -- easiest way to is to use quantum phase estimation libary on Grover Iterate as the oracle
// TODO when Bug #692 is fixed: Make combinators for implementations

/// <summary>
/// Converts phases specified as single-qubit rotations to phases as partial reflections
/// </summary>
/// <param name = "rotPhases"> Phase array </param>
/// <remarks> 
/// We use the convention in [ G.H. Low, I. L. Chuang, https://arxiv.org/abs/1707.05391] for relating single-qubit rotation phases to reflection operator phases.
/// </remarks>
function AmpAmpRotationToReflectionPhases( rotPhases : AmpAmpRotationPhases) : AmpAmpReflectionPhases
{
	let nPhasesRot = Length(rotPhases)
	let nPhasesRef = (nPhasesRot + 1) / 2
	
	//FailOn(nPhasesRot % 2 == 0, "Number of rotations must be odd.")

	mutable phasesTarget = new Double[nPhasesRef]
	mutable phasesStart = new Double[nPhasesRef]

	set phasesTarget[0] = rotPhases[0] - rotPhases[1] - Pi()
	set phasesStart[0] = - rotPhases[0] + 0.5 * Pi()

	for (idxPhases in 1..nPhasesRef-2){
		set phasesTarget[idxPhases] = rotPhases[2*idxPhases] - rotPhases[2*idxPhases + 1] - Pi()
		set phasesStart[idxPhases] = rotPhases[2*idxPhases-1] - rotPhases[2*idxPhases] + Pi()
	}

	set phasesTarget[nPhasesRef-1] = rotPhases[2*nPhasesRef-2] - 0.5 * Pi()
	set phasesStart[nPhasesRef-1] = rotPhases[2*nPhasesRef-3] - rotPhases[2*nPhasesRef-2] + Pi()

	return AmpAmpReflectionPhases(phasesTarget, phasesStart)
}


/// <summary>
/// Computes partial reflection phases for standard amplitude amplification.
/// </summary>
/// <param name = "rotPhases"> Number of application of iterate </param>
/// <remarks> 
/// All phases are Pi, except for the first reflection about the start state and the last reflection about the target state, which are 0.
/// </remarks>
function AmpAmpPhasesStandard(iterations : Int) : AmpAmpReflectionPhases{
	mutable phasesTarget = new Double[iterations+1]
	mutable phasesStart = new Double[iterations+1]
		

	for (idxPhases in 0..iterations){
		set phasesTarget[idxPhases] = Pi()
		set phasesStart[idxPhases] = Pi()
	}
	set phasesTarget[iterations] = 0.0
	set phasesStart[0] = 0.0

	return AmpAmpReflectionPhases(phasesTarget, phasesStart)
}


//We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014]
//See also "Methodology of composite quantum gates" [LowYoderChuang2016] for phases in the "AmpAmpRotationPhases" format
//function AmpAmpPhasesFixedPoint( lambdaMin : double, SuccessMin: double ) : (double[], double[]){

/// <summary>
/// Computes partial reflection phases for fixed-point amplitude amplification.
/// </summary>
/// <param name = "queries"> Number of queries to state preparation oracle (Must be an odd integer) </param>
/// <param name = "SuccessMin"> Target minimum success probability </param>
/// <remarks> 
/// We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014, https://arxiv.org/abs/1409.3305]
/// See also "Methodology of composite quantum gates" [LowYoderChuang2016, https://arxiv.org/abs/1603.03996] for phases in the "AmpAmpRotationPhases" format
/// </remarks>
function AmpAmpPhasesFixedPoint( queries: Int, successMin: Double ) : AmpAmpReflectionPhases
//(Double[], Double[])
{
	mutable phasesRot = new Double[queries]
	let queriesDouble = Float(queries)

	set phasesRot[0] = 0.0

	let beta = Cosh(1.0 / queriesDouble * ArcCosh( Sqrt(successMin) ))

	for (idxPhases in 1..queries - 1){
		set phasesRot[idxPhases] = phasesRot[idxPhases - 1] + 2.0 * ArcTan( Tan( 2.0 * 1.0 * Float(idxPhases) * Pi() / queriesDouble ) * Sqrt(1.0 - beta * beta)) 
	}

	return AmpAmpRotationToReflectionPhases(AmpAmpRotationPhases(phasesRot))
}



/// <summary>
/// Constructs reflection about a some state |ψ> from the oracle of type "OracleStateDeterministic" where O|0> = |ψ>
/// </summary>
/// <param name = "phase"> Phase of partial reflection </param>
/// <param name = "oracle"> Oracle of type "OracleStateDeterministic" </param>
/// <param name = "qubitsSystem"> Qubits acted on by "oracle" </param>
/// <remarks> 
/// -
/// </remarks>
operation ReflectionStartOracleStateDeterministicImpl(phase: Double, oracle: OracleStateDeterministic, qubitsSystem: Qubit[]): ()
{
	Body {
		(Adjoint oracle)(qubitsSystem)
		ReflectionAllZero(phase, qubitsSystem)
		oracle(qubitsSystem)
	}
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
function ReflectionStartOracleStateDeterministic(oracle: OracleStateDeterministic): OracleReflection
{
	return OracleReflection(ReflectionStartOracleStateDeterministicImpl(_, oracle, _ ))
}

/// <summary>
/// Constructs reflection about a some state |ψ> from the oracle of type "OracleState" where O|0>_f|0>_s = |ψ>_fs
/// </summary>
/// <param name = "phase"> Phase of partial reflection </param>
/// <param name = "oracle"> Oracle of type "OracleState" </param>
/// <param name = "qubitsFlag"> Flag qubit of "oracle" </param>
/// <param name = "qubitsSystem"> All other qubits acted on by "oracle" </param>
/// <remarks> 
/// -
/// </remarks>
operation ReflectionStartOracleStateImpl(phase: Double, oracle: OracleState, qubitFlag: Qubit, qubitsSystem: Qubit[]): ()
{
	Body {
		let qubits = [qubitFlag] + qubitsSystem
		(Adjoint oracle)(qubitFlag, qubitsSystem)
		ReflectionAllZero(phase, qubits)
		oracle(qubitFlag, qubitsSystem)
	}
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

operation ReflectionStartOracleStateImpl2(phase: Double, idxQubitFlag : Int, oracle: OracleState, qubits: Qubit[]): ()
{
	Body{
		let qubitFlag = qubits[idxQubitFlag]
		//let qubitsSystem = QubitExclude([idxQubitFlag], qubits)
		let qubitsSystem = qubits[1..3]
		ReflectionStartOracleStateImpl(phase, oracle, qubitFlag, qubitsSystem)
	}
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
function ReflectionStartOracleState(idxQubitFlag : Int, oracle: OracleState): OracleReflection
{
	return OracleReflection(ReflectionStartOracleStateImpl2( _ , idxQubitFlag , oracle , _ ))
}

/// <summary>
/// Constructs reflection about the target state uniquely marked by the flag qubit state |1>_f, prepared the oracle of type "OracleState"
/// </summary>
/// <param name = "phase"> Phase of partial reflection </param>
/// <param name = "qubitsFlag"> Flag qubit of oracle </param>
/// <param name = "qubitsSystem"> All other qubits acted on by oracle </param>
/// <remarks> 
/// -
/// </remarks>
operation ReflectionTargetOracleStateImpl(phase: Double, qubitFlag: Qubit, qubitsSystem: Qubit[]): ()
{
	Body {
		R1(phase, qubitFlag)
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
operation ReflectionTargetOracleStateImpl2(phase: Double, idxQubitFlag : Int, qubits: Qubit[]): ()
{
	Body {
		R1(phase, qubits[idxQubitFlag])
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
function ReflectionTargetOracleState(idxQubitFlag : Int): OracleReflection
{
	return OracleReflection(ReflectionTargetOracleStateImpl2( _ , idxQubitFlag , _ ))
}

/// <summary>
/// Oblivious amplitude amplification by specifying partial reflections.
/// </summary>
/// <param name = "phases"> Phases of partial reflections </param>
/// <param name = "refAncilla"> Reflection operator about start state of ancilla register </param>
/// <param name = "refTarget"> Reflection operator about target state of ancilla register </param>
/// <param name = "oracleSignal"> Unitary oracle of type "OracleOblivious" that acts jointly on the ancilla and system registers.</param>
/// <param name = "qubitsAncilla"> Ancilla register </param>
/// <param name = "qubitsSystem"> System register </param>
/// <remarks> 
/// Given a particular ancilla start state |start>_a, a particular ancilla target state |target>_a, and any system state |ψ>_s,
/// suppose that oracleSignal|start>_a|ψ>_s= λ|target>_a U|ψ>_s + sqrt{1-|λ|^2}... for some unitary U.
/// By a sequence of reflections about the start and target states on the ancilla register interleaved by applications of "oracleSignal" and its adjoint, the success probability of applying U may be altered.
/// In most cases, "qubitsAncilla" is initialized in the state |start>_a.
/// See [Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, Rolando D. Somma, https://arxiv.org/abs/1312.1414] for standard version.
/// See [G.H. Low, I.L. Chuang, https://arxiv.org/abs/1610.06546] for generalization to partial reflections.
/// </remarks>
operation AmpAmpObliviousByReflectionPhases(phases : AmpAmpReflectionPhases, refAncilla : OracleReflection, refTarget : OracleReflection, oracleSignal : OracleOblivious, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
{
	Body {
		let (phasesAncilla, phasesTarget) = phases
		let nphases = Length(phasesTarget)

		//FailOn(nphases != Length(phasesAncilla), "Phase array lengths not equal.")
		
		for (idxPhases in 0..nphases - 1){
			if(phasesAncilla[idxPhases] != 0.0) {
				refAncilla(phasesAncilla[idxPhases], qubitsAncilla)
			}

			if(idxPhases%2 == 0){
				oracleSignal(qubitsAncilla, qubitsSystem)
			}
			else{
				(Adjoint oracleSignal)(qubitsAncilla, qubitsSystem)
			}
			
			if(phasesTarget[idxPhases] != 0.0) {
				refTarget(phasesTarget[idxPhases], qubitsAncilla)
			}
		}
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}


/// <summary>
/// Oblivious amplitude amplification by oracles for partial reflections.
/// </summary>
/// <param name = "phases"> Phases of partial reflections </param>
/// <param name = "oracleAncilla"> Unitary oracle that prepares ancilla start state </param>
/// <param name = "oracleSignal"> Unitary oracle of type "OracleOblivious" that acts jointly on the ancilla and system registers.</param>
/// <param name = "qubitFlag"> Single-qubit flag register </param>
/// <param name = "qubitsAncilla"> Ancilla register </param>
/// <param name = "qubitsSystem"> System register </param>
/// <remarks> 
/// This imposes stricter conditions on form of the ancilla start and target states than in "AmpAmpObliviousByReflectionPhases".
/// It is assumed that oracleAncilla|0>_f|0>_a = |start>_fa prepares the ancilla start state |start>_fa from the computational basis |0>_f|0>_a.
/// It is assumed that the target state is marked by |1>_f.
/// It is assumed that oracleSignal|start>_fa|ψ>_s = λ|1>_f|anything>_a U|ψ>_s + sqrt{1-|λ|^2}|0>_f...
/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
/// </remarks>
operation AmpAmpObliviousByOraclePhases(phases : AmpAmpReflectionPhases, oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious, qubitFlag : Qubit, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
{
	Body {
		//Assert that qubitsAncilla are in |0...0> state?
		let qubits = [qubitFlag] + qubitsAncilla
		let idxQubitFlag = 0
		let refAncilla = ReflectionStartOracleStateDeterministic(oracleAncilla)
		let refTarget = ReflectionTargetOracleState(idxQubitFlag)
		

		AmpAmpObliviousByReflectionPhases(phases, refAncilla, refTarget, oracleSignal, qubits, qubitsSystem)
		
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

/// <summary>
/// Amplitude amplification by partial reflections.
/// </summary>
/// <param name = "phases"> Phases of partial reflections </param>
/// <param name = "refStart"> Reflection operator about start state </param>
/// <param name = "refTarget"> Reflection operator about target state </param>
/// <param name = "qubitsStart"> Qubit register </param>
/// <remarks> 
/// Amplitude amplification is a special case of oblivous amplitude amplification where there are no system qubits and the oblivious oracle is set to identity.
/// In most cases, "qubitsStart" is initialized in the state |start>_a, which is the -1 eigenstate of "refStart"
/// </remarks>
operation AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, refStart : OracleReflection, refTarget : OracleReflection, qubitsStart: Qubit[]) : ()
{
	Body {
		//Pass empty qubit array using fact that Identity2 does nothing
		let qubitEmpty = new Qubit[0]

		let oracleSignal = OracleOblivious(Identity2)

		AmpAmpObliviousByReflectionPhases(phases, refStart, refTarget, oracleSignal, qubitsStart, qubitEmpty) 
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

/// <summary>
/// Amplitude amplification by oracles for partial reflections.
/// </summary>
/// <param name = "phases"> Phases of partial reflections </param>
/// <param name = "oracleStatePrep"> Unitary oracle that prepares start state </param>
/// <param name = "qubitFlag"> Single-qubit flag register </param>
/// <param name = "qubitsStart"> Qubit register </param>
/// <remarks> 
/// This imposes stricter conditions on form of the start and target states than in "AmpAmpByReflectionPhases".
/// It is assumed that the target state is marked by |1>_f.
/// It is assumed that oracleStatePrep|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f...
/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
/// </remarks>
operation AmpAmpByOraclePhases(phases : AmpAmpReflectionPhases, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
{
	Body {
		//Assert that qubitsAncilla are in |0...0> state?
		let qubits = [qubitFlag] + qubitsStart
		let idxQubitFlag = 0
		let refStart = ReflectionStartOracleState(idxQubitFlag, oracleStatePrep)
		let refTarget = ReflectionTargetOracleState(idxQubitFlag)
		
		AmpAmpByReflectionsPhases(phases, refStart, refTarget, qubits)
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}


/// <summary>
/// Standard Amplitude Amplification algorithm
/// </summary>
/// <param name = "iterations"> Number of iterations of amplitude amplification </param>
/// <param name = "oracleStatePrep"> Unitary oracle that prepares start state </param>
/// <param name = "qubitFlag"> Single-qubit flag register </param>
/// <param name = "qubitsStart"> Qubit register </param>
/// <remarks> 
/// This is the standard amplitude amplification algorithm obtained by a choice of reflection phases computed by "AmpAmpPhasesStandard"
/// Assuming that oracleStatePrep|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f... = sin(θ)|1>_f|target>__s + cos(θ)|0>_f...,
/// this operation prepares the state AmpAmpByOracle|0>_f|0>_s = sin(2*iterations+1)|1>_f|target>__s + cos(2*iterations+1)|0>_f...,
/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
/// [G. Brassard, P. Hoyer, M. Mosca, A. Tapp, https://arxiv.org/abs/quant-ph/0005055]
/// </remarks>
operation AmpAmpByOracle(iterations: Int, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
{
	Body {
		let phases = AmpAmpPhasesStandard(iterations)

		AmpAmpByOraclePhases(phases, oracleStatePrep, qubitFlag, qubitsStart)
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

