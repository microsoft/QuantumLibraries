namespace Microsoft.Quantum.Canon {
	open Microsoft.Quantum.Primitive

	///Here we consider the smallest example of amplitude amplification
	///Suppose we have a single-qbuit oracle that prepares the state
	/// O |0> = \lambda |1> + \sqrt{1-|\lambda|^2} |0>
	/// The goal is to amplify the |1> state
	/// We can do this either by synthesizing the reflection about the start and target states ourselves,
	/// We can also do it by passing the oracle for state preparation
 
	operation ExampleStatePrepImpl( lambda : Double, qubitFlag : Qubit , qubitSystem : Qubit[] ) : ()
	{
		Body
		{
			let rotAngle = 2.0 * ArcSin(lambda)
			Ry(rotAngle, qubitFlag)
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
 
	}
	function ExampleStatePrep( lambda : Double ) : OracleState
	{
		return OracleState( ExampleStatePrepImpl (lambda, _, _) )
 
	}
 
	///In this mininal example, there are no system qubits, only a single flag qubit. 
	/// ExampleStatePrep is already of type  OracleState, so we call
	/// AmpAmpByOracle(iterations: Int, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
	operation ExampleAAbyOracle() : ()
	{
		Body{
			let lambda = 0.2
			let iterations = 3
			let oracleStatePrep = ExampleStatePrep(lambda)
			using(qubits = Qubit[1]){
				let qubitFlag = qubits[0]
				let qubitsSystem = new Qubit[0]
				AmpAmpByOracle(iterations, oracleStatePrep, 0, qubits)

				let successAmplitude = Sin( Float(2*iterations + 1) * ArcSin( lambda ))

				AssertProb([Zpauli], [qubitFlag], One, successAmplitude * successAmplitude, "Error: Success probability does not match theory", 1e-10)

				Reset(qubitFlag)
			}
		}
 
	}

}
