
//Example: Grover search

/// <summary>
/// Grover oracle from classical database
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// This implements the oracle O|z>|k> = |z \oplus x_k>|k> used in the Grover search algorithm.
/// Given a database with N = 2^n elements, n is the size of the database qubit register.
/// Let x = x_0x_1...x_{N-1} be a binary string of N elements. Then x_k is 1 if k is in "markedElements" and 0 otherwise.
/// </remarks>
operation GroverOracleFromInts(markedElements : Int[],  qubitFlag: Qubit, qubitsDatabase: Qubit[]) : ()
{
	Body{
		let nQubits = Length(qubitsDatabase)
		let nMarked = Length(markedElements)
		for(idxMarked in 0..nMarked - 1){
			ControlledOnInt(markedElements[idxMarked], ApplyToEachAC(X, _), qubitsDatabase, [qubitFlag])
		}

	}	

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto

}


/// <summary>
/// State preparation of marked stated from Grover oracle
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// This implements an oracle that prepares the start state O|0>_f|0>_d = |s>_fd = \sqrt{M/N}|1>_f|marked>_d + ... |0>_f|unmarked>_d.
/// M is the length of "markedElements"
/// N is 2^n, where n is the number of database qubits.
/// </remarks>
operation GroverOracleStatePrepImpl(markedElements : Int[], qubitFlag: Qubit , qubitsDatabase: Qubit[]) : ()
{
	Body{
		let nQubits = Length(qubitsDatabase)

		ApplyToEachAC(H, qubitsDatabase)

		GroverOracleFromInts(markedElements, qubitFlag, qubitsDatabase)

	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
operation GroverOracleStatePrep(markedElements : Int[]) : OracleState
{
	Body{
		let oracle = OracleState(GroverOracleStatePrepImpl(markedElements, _, _))
		return oracle
	}
}


/// <summary>
/// Grover search algorithm
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "iterations"> Number of applications of Grover iterate </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// On input |0>_f|0>_d, this prepares the state |1>_f|marked>_d with amplitude Sin((2*iterations + 1) ArcSin(Sqrt(M/N))).
/// </remarks>
operation GroverSearch( markedElements: Int[], iterations: Int, qubitFlag: Qubit , qubitsDatabase: Qubit[]) : ()
{
	Body{ 
        AmpAmpByOracle(iterations, GroverOracleStatePrep(markedElements), qubitFlag, qubitsDatabase) 
	}
	
}


operation GroverSearchImpl( markedElements: Int[], iterations: Int, qubitFlag: Qubit , qubitsDatabase: Qubit[]) : ()
{
	Body{   
        AmpAmpByOracle(iterations, GroverOracleStatePrep(markedElements), qubitFlag, qubitsDatabase) 
	}

}
//
operation GroverSearch2( markedElements: Int[], iterations: Int) : ((Qubit, Qubit[]) => ())
{
	Body{   
        return GroverSearchImpl(markedElements, iterations, _, _)
	}
}


/// <summary>
/// Grover search algorithm
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "iterations"> Number of applications of Grover iterate </param>
/// <param name = "nQubits"> Number of database qubits </param>
/// <remarks> 
/// This prepares the state |1>_f|marked>_d with amplitude Sin((2*iterations + 1) ArcSin(Sqrt(M/N))), measures all registers, and returns the value of the flag qubit and the value of the database register as an integer.
/// 2^qubitsDatabase should be larger than the largest integer in "markedElements"
/// </remarks>
operation GroverSearchMeasure( markedElements: Int[], iterations: Int, nQubits : Int) : (Result, Int)
{
    Body{ 

        mutable result = Zero
        mutable bits  = new Result[nQubits]
		mutable foundIndex = 0

		using(qubits = Qubit[1 + nQubits]){
			let qubitFlag = qubits[0]
			let qubitsDatabase = qubits[1..nQubits - 1]

			GroverSearch(markedElements, iterations, qubitFlag, qubitsDatabase) 

			set result = M(qubitFlag)
			set bits = MultiM(qubitsDatabase)

		   ResetAll(qubits)
           
		}
		set foundIndex = PositiveIntFromResultString(bits)
        
        return (result, foundIndex)

	}
}

/// <summary>
/// Test random instances of Grover search
/// </summary>
/// <param name = "maxMarkedElements"> Maximum number of marked elements in database </param>
/// <param name = "maxGroverIterations"> Maximum number of applications of Grover iterate </param>
/// <param name = "maxQubits"> Maximum number of database qubits </param>
/// <remarks> 
/// This generates 100 random instances of Grover search, each time by choosing a random number of database qubits n, a random number of marked elements M <= N = 2^maxQubits, and a random number of Grover iterations 
/// The success probability of measuring the flag qubit in the |1>_f state is compared to the theory of
/// Sin((2*iterations + 1) ArcSin(Sqrt(M/N)))^2
/// </remarks>
operation GroverTest( maxMarkedElements : Int, maxGroverIterations : Int , maxQubits: Int) :()
{
	Body {
		
		let nRepeats = 100
		mutable nElements = 0
		mutable nMarked = 0
		mutable nIterations = 0
		mutable nQubits = 0
		mutable markedElements = new Int[maxMarkedElements]
		mutable successAmplitude = 0.0
		for(idxRepeat in 0..nRepeats - 1)
		{
			set nMarked = randomInt(maxMarkedElements) + 1
			set nIterations = randomInt(maxGroverIterations) + 1
			set nQubits = randomInt(maxQubits) + 1
			set nElements = 2^nQubits - 1
			for(idxElement in 0..nMarked - 1){
				set markedElements[idxElement] = randomInt(nElements)
			}

			set successAmplitude = Sin( Float(2*nIterations + 1) * ArcSin( Sqrt(Float(nMarked) / Float(nElements)) ))

			using(qubits = Qubit[1 + nQubits]){
				let qubitFlag = qubits[0]
				let qubitsDatabase = qubits[1..nQubits - 1]

				GroverSearch(markedElements[0..nMarked-1], nIterations, qubitFlag, qubitsDatabase) 

				AssertProb([Zpauli], [qubitFlag], One, successAmplitude * successAmplitude, "Error: Success probability does not match theory", 1e-10)


				ResetAll(qubits)
			}

		}


		//
	}
}

