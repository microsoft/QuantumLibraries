//namespace Microsoft.Quantum.Canon

// TODO: move out somewhere, this is generically useful.
operation PrepareEntangledState(left : Qubit[], right : Qubit[]) : () {
    Body {
        if (Length(left) != Length(right)) {
            fail "Left and right registers must be the same length."
        }
        // TODO: assert both registers are in computational basis.

        for (idxQubit in 0..Length(left) - 1) {
            H(left[idxQubit])
            (Controlled X)([left[idxQubit]], right[idxQubit])
        }
    }
    
    Adjoint auto
    Controlled auto
    Controlled Adjoint auto
}

/// <summary>
///     Given two operations, asserts that they act identically for all input states.
///     This assertion is implemented by using the Choi–Jamiłkowski isomorphism to reduce
///     the assertion to one of a qubit state assertion on two entangled registers.
///     Thus, this operation needs only a single call to each operation being tested,
///     but requires twice as many qubits to be allocated.
///     This assertion can be used to ensure, for instance, that an optimized version of an
///     operation acts identically to its naïve implementation, or that an operation
///     which acts on a range of non-quantum inputs agrees with known cases.
/// </summary>
/// <remarks>
///     This operation requires that the operation modeling the expected behavior is
///     adjointable, so that the inverse can be performed on the target register alone.
///     Formally, one can specify a transpose operation, which relaxes this requirement,
///     but the transpose operation is not in general physically realizable for arbitrary
///     quantum operations and thus is not included here as an option.
/// </remarks>
/// <param name="actual">Operation to be tested.</param>
/// <param name="expected">Operation defining the expected behavior for the operation under test.</param>
/// <param name="nQubits">Number of qubits to pass to each operation.</param>
operation AssertOperationsEqualReferenced(actual : (Qubit[] => ()), expected : (Qubit[] => () : Adjoint), nQubits : Int) : () {
    Body {
        // Prepare a reference register entangled with the target register.
        using (reference = Qubit[nQubits]) {
            using (target = Qubit[nQubits]) {
                // FIXME: change to use With/Bind, but that depends on generics since the arguments take
                //        (Qubit[], Qubit[]), not Qubit[].
                PrepareEntangledState(reference, target)
                actual(target)
                (Adjoint expected)(target)
                (Adjoint PrepareEntangledState)(reference, target)

                ApplyToEach(AssertQubit(Zero, _), reference)
                ApplyToEach(AssertQubit(Zero, _), target)
            }
        }
    }
}
