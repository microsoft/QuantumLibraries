namespace Microsoft.Quantum.Canon {

    ///<summary> 
    /// Iterates a variable, say arr, through cartesian product 
    /// [ 0, bounds[0]-1 ] × [ 0, bounds[1]-1 ] × [ 0, bounds[Length(bounds)-1]-1 ]
    /// and calls op(arr) for every element of the cartesian product
    ///</summary>
    operation IterateThroughCartesianProduct( bounds : Int[], op : ((Int[]) => ()) ) : ()
    {
        Body
        {
            mutable arr = new Int[Length(bounds)]
            mutable finished = false
            repeat
            {
                op(arr)
            }
            until(finished)
            fixup
            {
                //computes the next element in the cartesian product
                set arr[0] = arr[0] + 1
                for( i in 0 .. Length(arr) -2 )
                {
                    if( arr[i] == bounds[i] )
                    {
                        set arr[i+1] = arr[i+1] + 1
                        set arr[i] = 0
                    }
                }
                if( arr[Length(arr) -1] == bounds[Length(arr) -1] )
                {
                    set finished = true
                }
            }
        }
    }

    ///<summary>
    /// Creates an array of given length with all elments equal to given value
    ///</summary>
    function MakeConstArray( length : Int, value : Int ) : Int[]
    {
        mutable arr = new Int[length]
        for( i in 0 .. length - 1 )
        {
            set arr[i] = value
        }
        return arr
    }

    ///<summary> 
    /// Iterates a variable, say arr, through cartesian product 
    /// [ 0, bound - 1 ] × [ 0, bound - 1 ] × [ 0, bound - 1 ]
    /// and calls op(arr) for every element of the cartesian product
    ///</summary>
    operation IterateThroughCartesianPower( power : Int, bound : Int, op : ((Int[]) => ()) ) : ()
    {
        Body
        {
            IterateThroughCartesianProduct(MakeConstArray(power,bound),op)
        }
    }

}