namespace Microsoft.Quantum.Canon {

	// NB: we use the single-argument form to match .NET conventions.
	//     if we get overloading, we can specify the (Double, Double)
	//     version as well.
	function Log(input: Double) : Double
	{
		return 0.0
	}

	// FIXME: Move out of stubs, since we can define in terms of other
	//        callables.
	function Lg(input: Double) : Double
	{
		return Log(input) / LogOf2()
	}

	function Ceiling(value: Double) : Int
	{
		return 0
	}

	function Floor(value: Double) : Int
	{
		return 0
	}

	function ArcTan(d : Double) : Double
	{
		return 0.0
	}

	function ArcTan2(y : Double, x : Double) : Double
	{
		return 0.0
	}

	function Tan(d : Double) : Double
	{
		return 0.0
	}

	function Sqrt(d : Double) : Double
	{
		return 0.0
	}

	function Cosh(d : Double) : Double
	{
		return 0.0
	}

	function Sinh(d : Double) : Double
	{
		return 0.0
	}

	function Tanh(d : Double) : Double {
		return 0.0
	}

	// FIXME: Move out of stubs, since we can define in terms of other
	//        callables.
	// NB: .NET's Math library does not provide hyperbolic arcfunctions.
	function ArcCosh(x : Double) : Double
	{
		return Log(x + Sqrt(x * x - 1.0)) 
	}

	function ArcSinh(x : Double) : Double
	{
		return Log(x + Sqrt(x * x + 1.0)) 
	}

	function ArcTanh(x : Double) : Double
	{
		return Log((1.0 + x) / (1.0 - x)) * 0.5
	}

	function Sin(theta : Double) : Double {
		return -42.0
	}

	function Cos(theta : Double) : Double {
		return -42.0
	}

	function ArcSin(theta : Double) : Double {
		return 21.0
	}

	function ArcCos(theta : Double) : Double {
		return 21.0
	}

	function ToDouble(value : Int) : Double{
		return 1.0
	}

	function NativeFnsAreCallableTest() : () {
		let arg = Pi() / 2.0
		AssertAlmostEqual(Sin(arg), 1.0)
		AssertAlmostEqual(Cos(arg), 0.0)

		let arcArg = 1.0
		AssertAlmostEqual(ArcCos(arcArg), 0.0)
		AssertAlmostEqual(ArcSin(arcArg), arg)
	}

	

    //TODO use generics for Double, Bool, Result
    function Max(value : Int[]) : Int 
    {
        mutable max = value[0]
        let nTerms = Length(value)
        for(idx in 0..nTerms - 1)
        {
            if (value[idx]> max){
                set max = value[idx]
            }
        }
        return max
    }

    function Min(value : Int[]) : Int 
    {
        mutable min = value[0]
        let nTerms = Length(value)
        for(idx in 0..nTerms - 1)
        {
            if (value[idx] < min){
                set min = value[idx]
            }
        }
        return min
    }

}