// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using Microsoft.Quantum.Diagnostics.Emulation;
using Microsoft.Quantum.Simulation.Common;
using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

namespace Microsoft.Quantum.Diagnostics
{

    public partial class AllowAtMostNCallsCA<__TInput__, __TOutput__>
    {
        public class Native : AllowAtMostNCallsCA<__TInput__, __TOutput__>
        {
            private SimulatorBase? Simulator;
            
            // NB: This is static rather than an instance field, as the
            //     simulation runtime does not guarantee that exactly one
            //     operation object will be constructed for each simulator.
            private static ConcurrentDictionary<IOperationFactory, Stack<IDisposable>> Handlers =
                new ConcurrentDictionary<IOperationFactory, Stack<IDisposable>>();

            private readonly IOperationFactory Key;

            public Native(IOperationFactory m) : base(m)
            {
                Simulator = m as SimulatorBase;
                Key = m;
            }

            public override Func<(long, ICallable, string), QVoid> __Body__ => _args =>
            {
                if (Simulator == null) return QVoid.Instance;

                var (nTimes, op, message) = _args;
                var callStack = ImmutableStack<string>.Empty;
                var callSites = ImmutableList<ImmutableStack<string>>.Empty;

                if (!Handlers.ContainsKey(Key))
                {
                    Handlers[Key] = new Stack<IDisposable>();
                }

                bool IsSelf(ICallable callable) =>
                    callable.FullName == "Microsoft.Quantum.Diagnostics.AllowAtMostNCallsCA";

                // Partial ordering on two variants; returns true, if `lhs` is included in `rhs`.
                // For example, Body <= Body, and Body <= Adjoint, but Controlled is not less than or equal Adjoint.
                bool LessThanOrEqual(OperationFunctor lhs, OperationFunctor rhs) => lhs switch {
                        OperationFunctor.ControlledAdjoint => rhs == OperationFunctor.ControlledAdjoint,
                        OperationFunctor.Controlled => rhs == OperationFunctor.ControlledAdjoint || rhs == OperationFunctor.Controlled,
                        OperationFunctor.Adjoint => rhs == OperationFunctor.ControlledAdjoint || rhs == OperationFunctor.Adjoint,
                        _ => true // OperationFunctor.Body
                };

                // Record whether or not the condition checked by this allow
                // has failed, so that we can property unwind in the endOperation
                // handler below.
                var failed = false;

                Handlers[Key].Push(Simulator.RegisterOperationHandlers(
                    startOperation: (callable, data) =>
                    {
                        if (IsSelf(callable)) return;
                        callStack = callStack.Push(callable.FullName);
                        // `callable` is callable we just entered on the call stack, `op` is the callable
                        // that we are monitoring with AllowAtMostNCallsCA.  We only increment the counter,
                        // if both callables have the same fully qualified name and if the variant of `op`
                        // is less restrictive than the one of `callable`.
                        if (callable.FullName == op.FullName && LessThanOrEqual(op.Variant, callable.Variant))
                        {
                            callSites = callSites.Add(callStack);
                            if (callSites.Count > nTimes)
                            {
                                Simulator?.MaybeDisplayDiagnostic(new CallSites
                                {
                                    Sites = callSites,
                                    Subject = op.FullName
                                });
                                failed = true;
                                throw new ExecutionFailException(
                                    $"Operation {op.FullName} was called more than the allowed {nTimes} times:\n{message}"
                                );
                            }
                        }
                    },

                    endOperation: (callable, data) =>
                    {
                        // Ignore call stack entries that happen after we've
                        // failed, or that are generated by ending the
                        // condition itself.
                        if (failed || IsSelf(callable)) return;
                        try
                        {
                            callStack = callStack.Pop();
                        }
                        catch (InvalidOperationException ex)
                        {
                            System.Console.WriteLine($"Call stack was empty when popped:\n{ex}");
                        }
                    }
                ));
                return QVoid.Instance;
            };

            public override Func<(long, ICallable, string), QVoid> __AdjointBody__ => _args =>
            {
                if (Simulator == null) return QVoid.Instance;

                Handlers[Key].Pop().Dispose();

                return QVoid.Instance;
            };
        }

    }

}
