// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Extensions.Convert;
    open Microsoft.Quantum.Extensions.Math;

    // Overview of amplitude amplification library
    // ===========================================
    //
    // Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here.
    // This is called through the operation AmpAmpObliviousByReflectionPhases.
    //
    //		This has two registers: "ancillaRegister" and "systemRegister".
    //		This accepts two oracles for these reflections of type "ReflectionOracle" which act only on the "ancillaRegister" register.
    //		This accepts an oracle special to oblivious amplitude amplification of type "ObliviousOracle" which acts jointly on both register.
    //		The input state to "ancillaRegister" is assumed to be the unique -1 eigenstate of the first reflection operator I - 2|s><s|.
    //
    // Reflections about a target quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis |0...0>.
    //		Our convention for these oracles requires two registers: a single-qubit "flagQubit" register, and a register for everything else on the ancillaRegister register.
    //		The oracle of type "StateOracle" acts jointly on both registers to create the target state flagged by |1> in the "flagQubit" register with some real amplitude.
    //		The reflection "ReflectionOracle" about the this flag state is generated by the operation "TargetStateReflectionOracle"
    //		The reflection "ReflectionOracle" about the input state to "ancillaRegister" is generated by the inverting StateOracle and then reflecting about |0...0> with ReflectionStart()
    //		The oracle of type "DeterministicStateOracle" acts on the "qubitState" registers to create the target state exactly with no flag.
    //
    // "AmpAmpObliviousByOraclePhases" is a version of oblivious amplitude amplification that accepts oracles "StateOracle" and "ObliviousOracle" instead of reflections.
    //
    // Note that amplitude amplification is a special case of oblivious amplitude amplifiction where "ObliviousOracle" is the identity operator, and there are no system qubits i.e. "systemRegister" is empty.
    //		This is called through the operaton "AmpAmByReflectionPhases" and "AmpAmpByOraclePhases".
    //
    // The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard.
    // For instance, we have the following dependencies: AmpAmpByOracle -> AmpAmpByOraclePhases -> AmpAmpObliviousByOraclePhases -> AmpAmpObliviousByReflectionPhases


    // TODO: Different parameter choice for fixed-point
    // TODO: Amplitude estimation -- easiest way to is to use quantum phase estimation libary on Grover Iterate as the oracle

    /// # Summary
    /// Converts phases specified as single-qubit rotations to phases specified as partial reflections.
    ///
    /// # Input
    /// ## rotPhases
    /// Array of single-qubit rotations to be converted to partial reflections.
    ///
    /// # Remarks
    /// We use the convention in [ G.H. Low, I. L. Chuang, https://arxiv.org/abs/1707.05391] for relating single-qubit rotation phases to reflection operator phases.
    function AmpAmpRotationToReflectionPhases( rotPhases : AmpAmpRotationPhases) : AmpAmpReflectionPhases
    {
        let nPhasesRot = Length(rotPhases);
        let nPhasesRef = (nPhasesRot + 1) / 2;

        if (nPhasesRot % 2 == 0) {
            fail "Number of rotations must be odd.";
        }

        mutable phasesTarget = new Double[nPhasesRef];
        mutable phasesStart = new Double[nPhasesRef];

        set phasesTarget[0] = rotPhases[0] - rotPhases[1] - PI();
        set phasesStart[0] = - rotPhases[0] + 0.5 * PI();

        for (idxPhases in 1..nPhasesRef - 2){
            set phasesTarget[idxPhases] = rotPhases[2*idxPhases] - rotPhases[2*idxPhases + 1] - PI();
            set phasesStart[idxPhases] = rotPhases[2*idxPhases-1] - rotPhases[2*idxPhases] + PI();
        }

        set phasesTarget[nPhasesRef-1] = rotPhases[2*nPhasesRef-2] - 0.5 * PI();
        set phasesStart[nPhasesRef-1] = rotPhases[2*nPhasesRef-3] - rotPhases[2*nPhasesRef-2] + PI();

        return AmpAmpReflectionPhases(phasesStart, phasesTarget);
    }


    /// # Summary
    /// Computes partial reflection phases for standard amplitude amplification.
    ///
    /// # Input
    /// ## nIterations
    /// Number of amplitude amplification iterations to generate partial reflection
    /// phases for.
    ///
    /// # Remarks
    /// All phases are p, except for the first reflection about the start state and the last reflection about the target state, which are 0.
    function AmpAmpPhasesStandard(nIterations : Int) : AmpAmpReflectionPhases{
        mutable phasesTarget = new Double[nIterations+1];
        mutable phasesStart = new Double[nIterations+1];


        for (idxPhases in 0..nIterations){
            set phasesTarget[idxPhases] = PI();
            set phasesStart[idxPhases] = PI();
        }
        set phasesTarget[nIterations] = 0.0;
        set phasesStart[0] = 0.0;

        return AmpAmpReflectionPhases(phasesStart, phasesTarget);
    }


    // We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014]
    // See also "Methodology of composite quantum gates" [LowYoderChuang2016] for phases in the "AmpAmpRotationPhases" format

    /// summary:
    ///     Computes partial reflection phases for fixed-point amplitude amplification.
    /// params:
    ///     nQueries: Number of queries to the state preparation oracle. Must be an odd integer.
    ///     successMin:Target minimum success probability.
    /// remarks:
    ///     We use the phases in "Fixed-Point Amplitude Amplification with
    ///     an Optimal Number of Queires" [YoderLowChuang2014, https://arxiv.org/abs/1409.3305].
    ///     See also "Methodology of composite quantum gates" [LowYoderChuang2016, https://arxiv.org/abs/1603.03996]
    ///     for phases in the "AmpAmpRotationPhases" format.
    function AmpAmpPhasesFixedPoint( nQueries: Int, successMin: Double ) : AmpAmpReflectionPhases
    {
        mutable phasesRot = new Double[nQueries];

        let nQueriesDouble = ToDouble(nQueries);
        set phasesRot[0] = 0.0;

        let beta = Cosh(1.0 / nQueriesDouble * ArcCosh( Sqrt(successMin) ));

        for (idxPhases in 1..nQueries - 1){
            set phasesRot[idxPhases] = phasesRot[idxPhases - 1] + 2.0 * ArcTan( Tan( 2.0 * 1.0 * ToDouble(idxPhases) * PI() / nQueriesDouble ) * Sqrt(1.0 - beta * beta));
        }

        return AmpAmpRotationToReflectionPhases(AmpAmpRotationPhases(phasesRot));
    }



    /// # Summary
    /// Oblivious amplitude amplification by specifying partial reflections.
    ///
    /// # Input
    /// ## phases
    /// Phases of partial reflections 
    /// ## ancillaReflection
    /// Reflection operator about start state of ancilla register 
    /// ## targetStateReflection
    /// Reflection operator about target state of ancilla register 
    /// ## signalOracle
    /// Unitary oracle of type "ObliviousOracle" that acts jointly on the ancilla and system registers.
    /// ## ancillaRegister
    /// Ancilla register 
    /// ## systemRegister
    /// System register 
    ///
    /// # Remarks
    /// Given a particular ancilla start state |start>_a, a particular ancilla target state |target>_a, and any system state |?>_s,
    /// suppose that signalOracle|start>_a|?>_s= ?|target>_a U|?>_s + sqrt{1-|?|^2}... for some unitary U.
    /// By a sequence of reflections about the start and target states on the ancilla register interleaved by applications of "signalOracle" and its adjoint, the success probability of applying U may be altered.
    /// In most cases, "ancillaRegister" is initialized in the state |start>_a.
    ///
    /// # References
    /// See [Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, Rolando D. Somma, https://arxiv.org/abs/1312.1414] for standard version.
    /// See [G.H. Low, I.L. Chuang, https://arxiv.org/abs/1610.06546] for generalization to partial reflections.
    operation AmpAmpObliviousByReflectionPhasesImpl(phases : AmpAmpReflectionPhases, ancillaReflection : ReflectionOracle, targetStateReflection : ReflectionOracle, signalOracle : ObliviousOracle, ancillaRegister: Qubit[], systemRegister: Qubit[]) : ()
    {
        body {
            let (phasesAncilla, phasesTarget) = phases;
            let nphases = 2 * Length(phasesTarget);

            //FailOn(nphases != Length(phasesAncilla), "Phase array lengths not equal.")
    
            if(phasesAncilla[0] != 0.0) {
                ancillaReflection(phasesAncilla[0], ancillaRegister);
            }
    
            for (idxPhases in 1..nphases - 1){
                let idxPhaseAncilla = (idxPhases / 2);
                let idxPhaseTarget = idxPhases / 2;

                if (idxPhases % 2 == 1) {
                    signalOracle(ancillaRegister, systemRegister);
                    if (phasesTarget[idxPhaseTarget] != 0.0) {
                        targetStateReflection(phasesTarget[idxPhaseTarget], ancillaRegister);
                    }
                }
                else {
                    (Adjoint signalOracle)(ancillaRegister, systemRegister);
                    if (phasesAncilla[idxPhaseAncilla] != 0.0) {
                        ancillaReflection(phasesAncilla[idxPhaseAncilla], ancillaRegister);
                    }
                }

            }
        }

        adjoint auto
        controlled auto
        adjoint controlled auto
    }

    function AmpAmpObliviousByReflectionPhases(phases : AmpAmpReflectionPhases, ancillaReflection : ReflectionOracle, targetStateReflection : ReflectionOracle, signalOracle : ObliviousOracle) : ((Qubit[], Qubit[]) => () : Adjoint, Controlled)
    {
        return AmpAmpObliviousByReflectionPhasesImpl(phases, ancillaReflection, targetStateReflection, signalOracle, _, _) ;
    }


    /// <summary>
    /// Oblivious amplitude amplification by oracles for partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "ancillaOracle"> Unitary oracle that prepares ancilla start state </param>
    /// <param name = "signalOracle"> Unitary oracle of type "ObliviousOracle" that acts jointly on the ancilla and system registers.</param>
    /// <param name = "idxFlagQubit"> Index to single-qubit flag register </param>
    /// <param name = "ancillaRegister"> Ancilla register </param>
    /// <param name = "systemRegister"> System register </param>
    /// <remarks> 
    /// This imposes stricter conditions on form of the ancilla start and target states than in "AmpAmpObliviousByReflectionPhases".
    /// It is assumed that ancillaOracle|0>_f|0>_a = |start>_fa prepares the ancilla start state |start>_fa from the computational basis |0>_f|0>_a.
    /// It is assumed that the target state is marked by |1>_f.
    /// It is assumed that signalOracle|start>_fa|?>_s = ?|1>_f|anything>_a U|?>_s + sqrt{1-|?|^2}|0>_f...
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// </remarks>
  
    function AmpAmpObliviousByOraclePhases(phases : AmpAmpReflectionPhases, ancillaOracle : DeterministicStateOracle, signalOracle : ObliviousOracle, idxFlagQubit : Int) : ((Qubit[], Qubit[]) => () : Adjoint, Controlled)
    {
        let ancillaReflection = ReflectionStart();
        let targetStateReflection = TargetStateReflectionOracle(idxFlagQubit);
        let oracleObliviousNew = ObliviousOracleFromDeterministicStateOracle(ancillaOracle, signalOracle);

        return AmpAmpObliviousByReflectionPhases(phases, ancillaReflection, targetStateReflection, oracleObliviousNew);
    }

    /// <summary>
    /// Amplitude amplification by partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "startStateReflection"> Reflection operator about start state </param>
    /// <param name = "targetStateReflection"> Reflection operator about target state </param>
    /// <param name = "startQubits"> Qubit register </param>
    /// <remarks> 
    /// Amplitude amplification is a special case of oblivous amplitude amplification where there are no system qubits and the oblivious oracle is set to identity.
    /// In most cases, "startQubits" is initialized in the state |start>_a, which is the -1 eigenstate of "startStateReflection"
    /// </remarks>
    function AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, startStateReflection : ReflectionOracle, targetStateReflection : ReflectionOracle) :  (Qubit[] => () : Adjoint, Controlled)
    {
        
        //Pass empty qubit array using fact that NoOp2 does nothing
        let qubitEmpty = new Qubit[0];

        let signalOracle = ObliviousOracle(NoOp2);

        return (AmpAmpObliviousByReflectionPhases(phases, startStateReflection, targetStateReflection, signalOracle))(_, qubitEmpty);
    }

    /// <summary>
    /// Amplitude amplification by oracles for partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "idxFlagQubit"> Index to Flag qubit </param>
    /// <param name = "qubits"> Start state register </param>
    /// <remarks> 
    /// This imposes stricter conditions on form of the start and target states than in "AmpAmpByReflectionPhases".
    /// It is assumed that the target state is marked by |1>_f.
    /// It is assumed that statePrepOracle|0>_f|0>_s = ?|1>_f|target>__s + sqrt{1-|?|^2}|0>_f...
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// </remarks>
    function AmpAmpByOraclePhases(phases : AmpAmpReflectionPhases, stateOracle : StateOracle, idxFlagQubit : Int) :  (Qubit[] => () : Adjoint, Controlled)
    {
        
        let qubitEmpty = new Qubit[0];
        let signalOracle = ObliviousOracle(NoOp2);
        let ancillaOracle = DeterministicStateOracleFromStateOracle(idxFlagQubit, stateOracle);
    
        return (AmpAmpObliviousByOraclePhases(phases, ancillaOracle, signalOracle, idxFlagQubit))(_, qubitEmpty);

    
    }

    /// <summary>
    /// Standard Amplitude Amplification algorithm
    /// </summary>
    /// <param name = "nIterations"> Number of iterations of amplitude amplification </param>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "idxFlagQubit"> Index to Flag qubit </param>
    /// <param name = "qubits"> Start state register </param>
    /// <remarks> 
    /// This is the standard amplitude amplification algorithm obtained by a choice of reflection phases computed by "AmpAmpPhasesStandard"
    /// Assuming that statePrepOracle|0>_f|0>_s = ?|1>_f|target>__s + sqrt{1-|?|^2}|0>_f... = sin(?)|1>_f|target>__s + cos(?)|0>_f...,
    /// this operation prepares the state AmpAmpByOracle|0>_f|0>_s = sin(2*nIterations+1)|1>_f|target>__s + cos(2*nIterations+1)|0>_f...,
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// [G. Brassard, P. Hoyer, M. Mosca, A. Tapp, https://arxiv.org/abs/quant-ph/0005055]
    /// </remarks>
    function AmpAmpByOracle(nIterations: Int, stateOracle : StateOracle, idxFlagQubit : Int) : (Qubit[] => () : Adjoint, Controlled)
    {
        let phases = AmpAmpPhasesStandard(nIterations);
        return AmpAmpByOraclePhases(phases, stateOracle, idxFlagQubit);
    }

    /// <summary>
    /// Fixed-Point Amplitude Amplification algorithm 
    /// </summary>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "startQubits"> Qubit register </param>
    /// <remarks> 
    /// startQubits must be in the |0..0> state. This iterates over a number of queries in powers of 2 until queriesMax 
    /// is reached, or the target state is found.
    /// </remarks>
    /// TODO test this.
    operation AmpAmpRUSByOracle(statePrepOracle : StateOracle, startQubits: Qubit[]) : ()
    {
        body {
            let queriesMax = 999; // Should be a power of 2
            let successMin = 0.99;
            mutable finished = Zero;
            mutable exponentMax = 0;
            mutable exponentCurrent = 0;

            //Complexity: Let \theta = \mathcal{O}(\sqrt{lambda}) 
            // Number of Measurements = O( Log^2(1/\theta) )
            // Number of Queries = O(1/\theta)
        
            using (flagQubit = Qubit[1]) {
                let qubits = flagQubit + startQubits;
                let idxFlagQubit = 0;
                repeat {
                    if( 2 ^ exponentMax > queriesMax ) {
                        fail "Target state not found. Maximum number of queries exceeded.";
                    }
                    repeat {
                        let queries = 2 ^ exponentCurrent;
                        let phases = AmpAmpPhasesFixedPoint( queries, successMin );
                        (AmpAmpByOraclePhases(phases, statePrepOracle, idxFlagQubit))(qubits);

                        set finished = M(flagQubit[0]);
                        set exponentCurrent = exponentCurrent + 1;
                    }
                    until(finished == One || exponentCurrent > exponentMax)
                    fixup {
                        // flagQubit is already in Zero for fixup to apply
                        ResetAll(startQubits);
                    }

                    set exponentCurrent = 0;
                    set exponentMax = exponentMax + 1;
                }
                until(finished == One)
                fixup {
                    ResetAll(startQubits);
                }
            }

        }
    }

}
